-- This script is idempotent, meaning it can be run multiple times without causing errors.

-- Create the table for menu permissions if it doesn't exist
CREATE TABLE IF NOT EXISTS public.menu_permissions (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    user_id bigint NOT NULL,
    menu_href character varying NOT NULL,
    is_accessible boolean NOT NULL DEFAULT true,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT menu_permissions_pkey PRIMARY KEY (id),
    -- Correctly references the public.users table which has a bigint id
    CONSTRAINT menu_permissions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users (id) ON DELETE CASCADE,
    CONSTRAINT menu_permissions_user_id_menu_href_key UNIQUE (user_id, menu_href)
);

-- Enable Row Level Security on the table
ALTER TABLE public.menu_permissions ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist to prevent errors on re-running the script
DROP POLICY IF EXISTS "Allow authenticated users to manage permissions" ON public.menu_permissions;
DROP POLICY IF EXISTS "Allow authenticated users to read permissions" ON public.menu_permissions;


-- Create a single, comprehensive policy for all actions.
-- This policy allows any authenticated user to SELECT, INSERT, UPDATE, or DELETE permissions.
-- The 'USING' clause applies to SELECT, UPDATE, DELETE.
-- The 'WITH CHECK' clause applies to INSERT, UPDATE, ensuring new/updated rows also meet the condition.
CREATE POLICY "Allow authenticated users to manage permissions"
    ON public.menu_permissions
    FOR ALL
    TO authenticated
    USING (auth.role() = 'authenticated')
    WITH CHECK (auth.role() = 'authenticated');


-- Notify Supabase of the schema changes to ensure API is up-to-date
NOTIFY pgrst, 'reload schema';
