-- Drop the foreign key constraint if it exists from a previous faulty attempt
ALTER TABLE IF EXISTS public.menu_permissions
DROP CONSTRAINT IF EXISTS menu_permissions_user_id_fkey;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Allow authenticated users to read permissions" ON public.menu_permissions;
DROP POLICY IF EXISTS "Allow authenticated users to manage permissions" ON public.menu_permissions;


-- Create the menu_permissions table
CREATE TABLE IF NOT EXISTS public.menu_permissions (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    user_id bigint NOT NULL,
    menu_href character varying NOT NULL,
    is_accessible boolean NOT NULL DEFAULT true,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT menu_permissions_pkey PRIMARY KEY (id),
    CONSTRAINT menu_permissions_user_id_menu_href_key UNIQUE (user_id, menu_href),
    -- Correctly reference the public.users table which has a bigint id
    CONSTRAINT menu_permissions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users (id) ON DELETE CASCADE
);

-- Enable Row Level Security
ALTER TABLE public.menu_permissions ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to read and manage permissions.
-- Note: Supabase policies using auth.uid() work with the internal auth.users table (uuid).
-- For this setup to be fully secure with public.users, a more complex setup with triggers or security functions is needed.
-- For now, we will allow any logged-in user to perform actions as a baseline.
CREATE POLICY "Allow authenticated users to read permissions"
    ON public.menu_permissions
    FOR SELECT
    USING (auth.role() = 'authenticated');

CREATE POLICY "Allow authenticated users to manage permissions"
    ON public.menu_permissions
    FOR ALL
    USING (auth.role() = 'authenticated');


-- Notify Supabase of the changes
NOTIFY pgrst, 'reload schema';
